import base64
import re
from Crypto.Util.number import *
from pwn import *
import math

# We say that for any two integers a,b, if gcd(a,b) = 1 then a and b are coprime integers.
# If a and b are prime, they are also coprime. If a is prime and b < a then a and b are coprime.
#  Think about the case for a prime and b > a, why are these not necessarily coprime?

# print(math.gcd(66528, 52920))

# The extended Euclidean algorithm is an efficient way to find integers u,v such that
# a * u + b * v = gcd(a,b)
#  Later, when we learn to decrypt RSA, we will need this algorithm to calculate the modular inverse of the public exponent.
# Using the two primes p = 26513, q = 32321, find the integers u,v such that
# p * u + q * v = gcd(p,q)
# Enter whichever of u and v is the lower number as the flag.
#  Knowing that p,q are prime, what would you expect gcd(p,q) to be?

# (additive inverse of negative index + x(+ve index) ) % len(list) = 0


# def gcd(a, b):
#     if b == 0:
#         return a
#     else:
#         return gcd(b, a % b)

# print(gcd(273246787654, 65537))


# def egcd(a, b):
#     if a == 0:
#         return b, 0, 1
#     gcd, x, y = egcd(b % a, a)
#     return gcd, y - (b // a) * x, x

# gcd, u, v = egcd(26513, 32321)
# print(f"Coefficients: ({u}, {v})")
# print("Greatest Common Divisor:", gcd)


# p = 29
# ints = [14, 6, 11]
# a = [x for x in range(1, p) if pow(x,2,p) in ints]
# print(a)

# Quadratic Residue * Quadratic Residue = Quadratic Residue
# Quadratic Residue * Quadratic Non-residue = Quadratic Non-residue
# Quadratic Non-residue * Quadratic Non-residue = Quadratic Residue
# Want an easy way to remember this? Replace "Quadratic Residue" with +1 and "Quadratic Non-residue" with -1, all three results are the same!

# Legendre's Symbol: (a / p) ≡ a(p-1)/2 mod p obeys:

# (a / p) = 1 if a is a quadratic residue and a ≢ 0 mod p
# (a / p) = -1 if a is a quadratic non-residue mod p
# (a / p) = 0 if a ≡ 0 mod p

# Which means given any integer a, calculating pow(a,(p-1)//2,p) is enough to determine if a is a quadratic residue.

# p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139

# ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]

def legendre(a, p):
    """
    Returns the Legendre symbol (a/p).
    """
    if a == 0:
        return 0
    elif pow(a, (p - 1) // 2, p) == p - 1:
        return -1
    else:
        return 1

def tonelli_shanks(n, p):
    """
    Computes the square root of a quadratic residue n modulo a prime p
    using the Tonelli-Shanks algorithm.
    Returns a tuple containing the two possible square roots of n.
    """
    # Check if n is a quadratic residue modulo p
    if pow(n, (p-1)//2, p) != 1:
        return None
    
    # Case when p is congruent to 3 modulo 4
    if p % 4 == 3:
        print('Case: 3 mod 4')
        r = pow(n, (p+1)//4, p)
        return (r, p-r)
    
    # Case when p is congruent to 1 modulo 4
    print('Case: 1 mod 4')
    s = p - 1
    e = 0
    while s % 2 == 0:
        s //= 2
        e += 1
        
    # Find a quadratic non-residue of p by brute force
    q = 2
    while pow(q, (p-1)//2, p) != p-1:
        q += 1
        
    x = pow(n, (s+1)//2, p)
    b = pow(n, s, p)
    g = pow(q, s, p)
    r = e
    
    while True:
        if b == 1:
            return (x, p-x)
        
        t = b
        m = 0
        while t != 1:
            t = pow(t, 2, p)
            m += 1
            
        g1 = pow(g, 1 << (r-m-1), p)
        g = pow(g1, 2, p)
        x = (x * g1) % p
        b = (b * g) % p
        r = m

# res = [a for a in ints if (pow(a,(p-1)//2,p) == 1)]
# a = res[0]
# x = tonelli_shanks(a, p)
# print(max(x))

# print(tonelli_shanks(59994699156557370130424995593983676093114752057004772155916429822613297164524571647549287520904196781355761928360352653374490476397430387622585911907520674106915700623243083784346493693709885211822797129548390636709757599335107034206525502331143082429257178016824886309253284955147985343555683418355197498464312506143216052381983103514337628992209, 159117138695601086935648462476725143896981591038416901486093706070754873563937272793294757366059667782136312013577603110660003394277897367203934519905683172161079448635248857040486200482627367334414675502994685936812333774063439076898281362682381888787053539531164627370506379676784327677612773681859553362469))

# All primes that aren't 2 are of the form p ≡ 1 mod 4 or p ≡ 3 mod 4, since all odd numbers obey these congruences. As the previous challenge hinted, in the p ≡ 3 mod 4 case, a really simple formula for computing square roots can be derived directly from Fermat's little theorem. That leaves us still with the p ≡ 1 mod 4 case, so a more general algorithm is required.

# In a congruence of the form r2 ≡ a mod p, Tonelli-Shanks calculates r.

# Tonelli-Shanks doesn't work for composite (non-prime) moduli. Finding square roots modulo composites is computationally equivalent to integer factorization - that is, it's a hard problem.

# The main use-case for this algorithm is finding elliptic curve co-ordinates. Its operation is somewhat complex so we're not going to discuss the details, however, implementations are easy to find and Sage has one built-in.

# a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768
# p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161

# print(legendre(a, p))
# x = tonelli_shanks(a, p)
# print(min(x))


# In cryptography, we commonly use the Chinese Remainder Theorem to help us reduce a problem of very large integers into a set of several, easier problems.

# a = [2,3,5]
# n = [5,11,17]

# length = len(a)

# Ntot= n[0] * n[1] * n[2]

# N = [ n[1]*n[2] , n[0]*n[2], n[0]*n[1] ]

# y = [pow(N[i],n[i]-2,n[i]) for i in range(length)]

# mysterious_a = 0
# for i in range(length):
#         mysterious_a += a[i]*N[i]*y[i]
# mysterious_a %= Ntot

# print(mysterious_a)

# quadratic equation

p = 159117138695601086935648462476725143896981591038416901486093706070754873563937272793294757366059667782136312013577603110660003394277897367203934519905683172161079448635248857040486200482627367334414675502994685936812333774063439076898281362682381888787053539531164627370506379676784327677612773681859553362469
a = 183170230465848410077175594145038110799
b = 177960951503783858139483105160729532851
c = 241771663291314104599898559749454094799
y = 81883801483428304918741984834363388238539421922474300691841915944763281416203781633389084991872486015041884084357260412052258732056118424392145242000539134316390251752292462492913837148154805999331901388735321855253311517735430229163344305926114721299791844599487270387540543138183327842649901510556454592197


d = pow(b, 2, p) - 4*a*(c-y) % p

(x2, x1) = tonelli_shanks(d, p)

res = pow(((p+1)*(x1-b))//2, 1, p)//a

print(long_to_bytes(res))
