# n = 117748628925689053050466090051826185640663888720594132523301186314981382005363199839988308086823416485003527786232198213017292596250969554140839099267347390188285286460281557476849525057301972550725756129489495182030052967340128984598159617454649617087100397347668419829784981546076924015147233638069123367689
# e = 65537
# c = 12432966760595525612686668965647095981796010789264387261413637609783678001038925582492382421788541686426690805911813433229709050374547462939521510990287221988438352877448641863134871463465766706740786825023348430967768344056001453221215663234390237873003521457165857639552025717723263950597556775928076127094
# # We don't know the private key d, but we know c and n. So how do we trick the program to accept c as an input? Well we realize that:
# # c^d mod(n) == (c+n)^d mod(n)

# # pt1^e = c1, pt2^e = c2
# # As no padding, pt1^e * pt2^e (mod n) = (pt1 * pt2)^e mod n
# # So let pt1 = 2. 2^e * flag^e (mod n) on decrypt, i.e.,
# # (2*flag)^e (mod n) on decrypt gives flag*2
# recv = 290275030195850039473456618367455885069965748851278076756743720446703314517401359267322769037469251445384354856017744835453
# print(bytes.fromhex(format(recv, 'x')).decode())
